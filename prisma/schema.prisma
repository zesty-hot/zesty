generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  ADMIN
  STAFF
  USER
}

model Images {
  id        String   @id @default(cuid())
  url       String
  width     Int
  height    Int
  altText   String?
  default   Boolean @default(false)
  NSFW      Boolean @default(false)

  user      User?    @relation(fields: [userId], references: [id])
  userId    String?

  createdAt DateTime @default(now())

  @@index([userId], map: "images_userId_idx")
}

enum Race {
  ASIAN
  AFRICAN
  HISPANIC
  WHITE
  DESI
  ARABIC
}

enum BodyType {
  REGULAR
  PLUS
  ATHLETE
}

enum Gender {
  MALE
  FEMALE
  TRANS
}

model User {
  id          String @id @default(cuid())
  accounts     Account[]
  sessions     Session[]

  name        String?
  title       String? @db.VarChar(200) // Unified title across all pages
  bio         String? @db.VarChar(1000)
  email       String @unique
  emailVerified DateTime?
  slug        String? @unique
  image       String?
  role        Role    @default(USER)
  dob         DateTime?
  stripeId    String?
  verified    Boolean @default(false)
  onboardingCompleted Boolean @default(false)
  mobile      String? @db.VarChar(15)
  location    String? @db.VarChar(100) // Latitude, Longitude
  suburb      String? @db.VarChar(100) // Suburb/City name
  bodyType    BodyType?
  race        Race?
  gender      Gender?

  privateAds             PrivateAd[]
  images                 Images[]
  privateOffersSent      PrivateOffer[] @relation("offersSent")
  privateOffersReceived  PrivateOffer[] @relation("offersReceived")

  vipPage             VIPPage?
  vipSubscriptions    VIPSubscription[] @relation("vipSubscriber")
  vipLikes            VIPLike[] @relation("vipLikes")
  vipComments         VIPComment[] @relation("vipComments")

  liveStreamPage      LiveStreamPage?
  liveStreamFollows   LiveStreamFollower[]
  liveStreamDonations LiveStreamDonation[]

  eventsOrganized     Event[] @relation("eventOrganizer")
  eventsAttending     EventAttendee[] @relation("eventAttendee")
  eventPosts          EventPost[] @relation("eventPostAuthor")
  eventComments       EventComment[] @relation("eventCommentAuthor")

  studiosOwned        Studio[] @relation("studioOwner")
  studioAdmins        StudioAdmin[] @relation("studioAdminUser")
  jobApplications     JobApplication[] @relation("jobApplicant")
  studioReviews       StudioReview[] @relation("studioReviewer")

  messagesSent ChatMessage[] @relation("sender")
  messagesRead MessageRead[] @relation("messageReads")
  activeChats  Chat[] @relation("activeChat")
  hiddenChats  Chat[] @relation("hiddenChat")

  reviewsGiven    Review[] @relation("reviewer")
  reviewsReceived Review[] @relation("reviewee")

  lastActive      DateTime? @default(now())
  createdAt       DateTime @default(now())

  datingPages DatingPage[]
}

model VIPPage {
  id              String @id @default(cuid())

  description     String @db.VarChar(3000)
  bannerUrl       String? // Banner image for the VIP page
  active          Boolean @default(true)
  
  // Pricing
  subscriptionPrice Int @default(999) // Price in cents (e.g., 999 = $9.99)
  isFree            Boolean @default(false)

  user            User @relation(fields: [userId], references: [id])
  userId          String

  content         VIPContent[]
  subscriptions   VIPSubscription[]
  discountOffers  VIPDiscountOffer[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId])  
}

enum VIPContentType {
  IMAGE
  VIDEO
  STATUS
}

model VIPContent {
  id          String @id @default(cuid())
  
  type        VIPContentType
  caption     String? @db.VarChar(1000)
  
  // For images
  imageUrl    String?
  imageWidth  Int?
  imageHeight Int?
  
  // For videos
  videoUrl    String?
  thumbnailUrl String?
  duration    Int? // Duration in seconds
  
  // For status updates
  statusText  String? @db.VarChar(5000)
  
  NSFW        Boolean @default(false)
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  likes       VIPLike[]
  comments    VIPComment[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([vipPageId, createdAt])
}

model VIPSubscription {
  id          String @id @default(cuid())
  
  subscriber  User @relation("vipSubscriber", fields: [subscriberId], references: [id])
  subscriberId String
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  active      Boolean @default(true)
  expiresAt   DateTime? // Null for lifetime/free subscriptions
  
  // Payment tracking
  amountPaid  Int // Amount in cents
  stripeSubscriptionId String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([subscriberId, vipPageId])
  @@index([subscriberId])
  @@index([vipPageId])
}

model VIPDiscountOffer {
  id          String @id @default(cuid())
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  discountPercent Int // 0-100
  discountedPrice Int // Price in cents after discount
  
  active      Boolean @default(true)
  validFrom   DateTime @default(now())
  validUntil  DateTime?
  
  createdAt   DateTime @default(now())

  @@index([vipPageId, active])
}

model VIPLike {
  id          String @id @default(cuid())
  
  user        User @relation("vipLikes", fields: [userId], references: [id])
  userId      String
  
  content     VIPContent @relation(fields: [contentId], references: [id], onDelete: Cascade)
  contentId   String
  
  createdAt   DateTime @default(now())

  @@unique([userId, contentId])
  @@index([contentId])
}

model VIPComment {
  id          String @id @default(cuid())
  
  user        User @relation("vipComments", fields: [userId], references: [id])
  userId      String
  
  content     VIPContent @relation(fields: [contentId], references: [id], onDelete: Cascade)
  contentId   String
  
  text        String @db.VarChar(1000)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([contentId, createdAt])
}

model Review {
  id          String @id @default(cuid())
  comment     String? @db.VarChar(1000)
  rating      Int @db.SmallInt

  reviewer    User @relation("reviewer", fields: [reviewerId], references: [id])
  reviewerId  String

  reviewee    User @relation("reviewee", fields: [revieweeId], references: [id])
  revieweeId  String
 
  offer       PrivateOffer? @relation(fields: [offerId], references: [id])
  offerId     String?

  createdAt   DateTime @default(now())  
}

model Account {
  id                String  @id @default(cuid())
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum PrivateAdExtraType {
  FILMING
  BJ
  ANAL
  BDSM
  NATURAL
  EXTRA_PERSON
  OUTSIDE_LOCATION
  COSTUME
  ROLEPLAY
  TOY_USE
  CREAMPIE
  GOLDEN_SHOWER
  LIVE_STREAM
}

enum PrivateAdCustomerCategory {
  MEN
  WOMEN
  GROUPS
  TRANSGENDER
  DISABLED
}

enum PrivateAdServiceCategory {
  MEET_AND_GREET
  MASSAGE
  IN_CALL
  OUT_CALL
}

enum DaysAvailable {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

model PrivateAdService {
  id            String @id @default(cuid())

  privateAd     PrivateAd @relation(fields: [privateAdId], references: [id])
  privateAdId   String

  category      PrivateAdServiceCategory // IN_CALL, OUT_CALL, NON_SEXUAL, OVERNIGHT
  label         String? // optional display name, e.g. “Public meet-up”

  options       ServiceOption[] // durations and prices

  createdAt     DateTime @default(now())
}

model ServiceOption {
  id            String @id @default(cuid())
  service       PrivateAdService @relation(fields: [serviceId], references: [id])
  serviceId     String

  durationMin   Int      // 15, 30, 60
  price         Int      // price in dollars
}

model PrivateAdExtra {
  id            String @id @default(cuid())
  privateAd     PrivateAd @relation(fields: [privateAdId], references: [id])
  privateAdId   String

  name          PrivateAdExtraType // BJ, ANAL, BDSM, FILMING
  price         Int
  active        Boolean @default(true)
}

model PrivateAd {
  id              String @id @default(cuid())

  title           String @db.VarChar(200)
  description     String @db.VarChar(3000)
  active          Boolean @default(true)

  services        PrivateAdService[]
  acceptsGender   PrivateAdCustomerCategory[]
  acceptsRace     Race[]
  acceptsBodyType BodyType[]
  acceptsAgeRange Int[]  // [minAge, maxAge]
  extras          PrivateAdExtra[]
  daysAvailable   DaysAvailable[]

  worker          User @relation(fields: [workerId], references: [id])
  workerId        String

  createdAt       DateTime @default(now())

  @@unique([workerId])
}

enum PrivateOfferStatus {
  PENDING
  CONFIRMED
  DISPUTED
  RELEASED
}

model PrivateOffer {
  id            String @id @default(cuid())
  amount        Int
  adId          String

  status        PrivateOfferStatus @default(PENDING)
  expiresAt     DateTime?

  client        User @relation("offersSent", fields: [clientId], references: [id])
  clientId      String
  worker        User @relation("offersReceived", fields: [workerId], references: [id])
  workerId      String

  chat          Chat? @relation(fields: [chatId], references: [id])
  chatId        String?

  createdAt     DateTime @default(now())

  Review Review[]
}

model Chat {
  id        String @id @default(cuid())
  messages  ChatMessage[]

  createdAt DateTime @default(now())

  activeUsers User[] @relation("activeChat")
  hiddenUsers User[] @relation("hiddenChat")

  PrivateOffer PrivateOffer[]
  datingMatch  DatingMatch?
}

model ChatMessage {
  id        String @id @default(cuid())

  sender    User    @relation("sender", fields: [senderId], references: [id])
  senderId  String

  content   String @db.VarChar(1000)

  createdAt DateTime @default(now())

  chat Chat @relation(fields: [chatId], references: [id])
  chatId String

  readBy    MessageRead[]
}

model MessageRead {
  id        String @id @default(cuid())

  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId String

  user      User @relation("messageReads", fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  readAt    DateTime @default(now())

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

model DatingPage {
  id              String @id @default(cuid())
  
  // Preferences
  lookingFor      String[] @default([])      // What they're looking for: "dating", "friends", "hookup", "relationship"
  ageRangeMin     Int @default(18)
  ageRangeMax     Int @default(100)
  maxDistance     Int @default(50)           // Max distance in km
  showGender      Gender[] @default([])      // What genders to show
  
  active          Boolean @default(true)     // Profile enabled/disabled
  verified        Boolean @default(false)    // Verified dating profile
  
  // Relations
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  swipesGiven     DatingSwipe[] @relation("swiper")
  swipesReceived  DatingSwipe[] @relation("swiped")
  matchesAsUser1  DatingMatch[] @relation("user1")
  matchesAsUser2  DatingMatch[] @relation("user2")
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId])
  @@index([active, createdAt])
}

// Swipe actions (like/pass)
model DatingSwipe {
  id              String @id @default(cuid())
  
  swiperId        String             // User who swiped
  swiper          DatingPage @relation("swiper", fields: [swiperId], references: [id], onDelete: Cascade)
  
  swipedId        String             // User who was swiped on
  swiped          DatingPage @relation("swiped", fields: [swipedId], references: [id], onDelete: Cascade)
  
  direction       SwipeDirection     // Like or Pass
  superLike       Boolean @default(false)
  
  createdAt       DateTime @default(now())

  @@unique([swiperId, swipedId])
  @@index([swiperId, createdAt])
  @@index([swipedId, direction])
}

// Matches (when both users like each other)
model DatingMatch {
  id              String @id @default(cuid())
  
  user1Id         String
  user1           DatingPage @relation("user1", fields: [user1Id], references: [id], onDelete: Cascade)
  
  user2Id         String
  user2           DatingPage @relation("user2", fields: [user2Id], references: [id], onDelete: Cascade)
  
  // Chat for this match
  chatId          String? @unique
  chat            Chat? @relation(fields: [chatId], references: [id], onDelete: SetNull)
  
  unmatchedBy     String?            // If unmatched, who unmatched
  unmatchedAt     DateTime?
  
  createdAt       DateTime @default(now())

  @@unique([user1Id, user2Id])
  @@index([user1Id, createdAt])
  @@index([user2Id, createdAt])
}

enum SwipeDirection {
  LIKE
  PASS
}

// LiveStreamPage is a channel/profile for livestreaming (like a sub-account)
// It can be enabled/disabled and has its own followers
model LiveStreamPage {
  id              String @id @default(cuid())
  
  description     String? @db.VarChar(3000)
  bannerUrl       String?          // Banner image for the channel
  
  active          Boolean @default(false)  // Channel enabled/disabled
  
  // RTMP/Stream key for broadcasting (persistent per channel)
  ingressId       String?          // LiveKit ingress ID for RTMP/WHIP
  streamKey       String?          // Stream key for broadcasting
  
  // Relations
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  followers       LiveStreamFollower[]
  streams         LiveStream[]     // Individual streaming sessions
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId])
  @@index([active, createdAt])
}

// Individual live stream sessions within a channel
model LiveStream {
  id              String @id @default(cuid())
  
  title           String? @db.VarChar(200)  // Optional custom title for this session
  
  isLive          Boolean @default(true)    // Currently streaming
  roomName        String @unique            // LiveKit room for this session
  
  viewerCount     Int @default(0)           // Current/peak viewers
  
  startedAt       DateTime @default(now())
  endedAt         DateTime?
  
  // Relations
  channel         LiveStreamPage @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelId       String
  
  donations       LiveStreamDonation[]
  
  @@index([channelId, isLive])
  @@index([isLive, startedAt])
}

// Followers for livestream channels
model LiveStreamFollower {
  id              String @id @default(cuid())
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  channel         LiveStreamPage @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelId       String
  
  createdAt       DateTime @default(now())

  @@unique([userId, channelId])
  @@index([channelId])
  @@index([userId])
}

// Donations/tips to live streams
model LiveStreamDonation {
  id              String @id @default(cuid())
  
  amount          Int              // Amount in cents
  message         String? @db.VarChar(500)
  
  donor           User? @relation(fields: [donorId], references: [id])
  donorId         String?
  
  stream          LiveStream @relation(fields: [streamId], references: [id], onDelete: Cascade)
  streamId        String
  
  createdAt       DateTime @default(now())

  @@index([streamId, createdAt])
}

// ==================== EVENTS ====================

enum EventStatus {
  OPEN                // Anyone can join
  INVITE_ONLY        // Only invited users can join
  PAY_TO_JOIN        // Payment required to join
  REQUEST_TO_JOIN    // Users request, host approves
}

model Event {
  id              String @id @default(cuid())
  
  title           String @db.VarChar(200)
  description     String? @db.Text
  slug            String @unique
  
  // Location
  location        String? @db.VarChar(100)  // Latitude, Longitude
  suburb          String? @db.VarChar(100)  // Suburb/City name
  venue           String? @db.VarChar(200)  // Venue name/address
  
  // Images
  coverImage      String?
  
  // Event details
  startTime       DateTime
  endTime         DateTime?
  status          EventStatus @default(OPEN)
  price           Int? // Price in cents (if PAY_TO_JOIN)
  maxAttendees    Int? // Maximum number of attendees
  
  // Organizer
  organizer       User @relation("eventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  organizerId     String
  
  // Relations
  attendees       EventAttendee[]
  posts           EventPost[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([organizerId])
  @@index([startTime])
  @@index([suburb, startTime])
  @@index([status, startTime])
}

model EventAttendee {
  id              String @id @default(cuid())
  
  // Attendee status
  status          EventAttendeeStatus @default(PENDING)
  
  event           Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId         String
  
  user            User @relation("eventAttendee", fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([eventId, status])
  @@index([userId])
}

enum EventAttendeeStatus {
  PENDING         // Requested to join (for REQUEST_TO_JOIN events)
  GOING           // Confirmed attendance
  MAYBE           // Interested/maybe going
  DECLINED        // Declined invitation
  INVITED         // Invited but not responded (for INVITE_ONLY)
}

model EventPost {
  id              String @id @default(cuid())
  
  content         String @db.Text
  
  event           Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId         String
  
  author          User @relation("eventPostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  authorId        String
  
  comments        EventComment[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([eventId, createdAt])
  @@index([authorId])
}

model EventComment {
  id              String @id @default(cuid())
  
  content         String @db.Text
  
  post            EventPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId          String
  
  author          User @relation("eventCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  authorId        String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([authorId])
}

// ==================== STUDIOS & JOBS ====================

enum JobType {
  ACTOR              // Adult film actor/performer
  DIRECTOR           // Director
  CAMERA_OPERATOR    // Camera/photography
  EDITOR             // Video editor
  PRODUCTION_STAFF   // General production
  MODEL              // Photo/video model
  OTHER              // Other roles
}

enum JobStatus {
  OPEN               // Currently accepting applications
  CLOSED             // No longer accepting applications
  FILLED             // Position has been filled
  CANCELLED          // Job posting cancelled
}

enum ApplicationStatus {
  PENDING            // Application submitted, awaiting review
  ACCEPTED           // Application accepted
  REJECTED           // Application rejected
  WITHDRAWN          // Applicant withdrew
}

model Studio {
  id              String @id @default(cuid())
  
  name            String @db.VarChar(200)
  slug            String @unique
  description     String? @db.Text
  
  // Images
  logo            String?
  coverImage      String?
  
  // Location
  location        String? @db.VarChar(100)  // Latitude, Longitude
  suburb          String? @db.VarChar(100)  // Suburb/City name
  
  // Contact
  website         String? @db.VarChar(200)
  email           String? @db.VarChar(100)
  
  // Verification
  verified        Boolean @default(false)
  active          Boolean @default(true)
  
  // Owner (creator of the studio)
  owner           User @relation("studioOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId         String
  
  // Relations
  admins          StudioAdmin[]
  jobs            Job[]
  reviews         StudioReview[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([ownerId])
  @@index([slug])
  @@index([active, createdAt])
  @@index([suburb])
}

model StudioAdmin {
  id              String @id @default(cuid())
  
  studio          Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
  studioId        String
  
  user            User @relation("studioAdminUser", fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  // Permissions (can be expanded later)
  canPostJobs     Boolean @default(true)
  canManageJobs   Boolean @default(true)
  canInviteAdmins Boolean @default(false)
  
  createdAt       DateTime @default(now())

  @@unique([studioId, userId])
  @@index([studioId])
  @@index([userId])
}

model Job {
  id              String @id @default(cuid())
  
  title           String @db.VarChar(200)
  slug            String @unique
  description     String @db.Text
  
  // Job type
  type            JobType
  
  // Pay
  payAmount       Int                    // Amount in cents
  payType         String @default("FIXED") // FIXED, HOURLY, DAILY, etc.
  
  // Duration
  lengthHours     Int?                   // Duration in hours
  lengthDays      Int?                   // Or duration in days
  
  // Location
  location        String? @db.VarChar(100)  // Latitude, Longitude
  suburb          String? @db.VarChar(100)  // Suburb/City name
  venue           String? @db.VarChar(200)  // Specific location/studio address
  
  // Filming dates
  startDate       DateTime
  endDate         DateTime?
  
  // Requirements
  requirements    String? @db.Text       // Additional requirements/qualifications
  
  // Images
  coverImage      String?
  
  // Status
  status          JobStatus @default(OPEN)
  maxApplicants   Int?                   // Maximum number of applicants
  
  // Studio
  studio          Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
  studioId        String
  
  // Relations
  applications    JobApplication[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([studioId])
  @@index([slug])
  @@index([status, startDate])
  @@index([type, status])
  @@index([suburb, status])
}

model JobApplication {
  id              String @id @default(cuid())
  
  // Application details
  coverLetter     String? @db.Text
  status          ApplicationStatus @default(PENDING)
  
  // Job
  job             Job @relation(fields: [jobId], references: [id], onDelete: Cascade)
  jobId           String
  
  // Applicant
  applicant       User @relation("jobApplicant", fields: [applicantId], references: [id], onDelete: Cascade)
  applicantId     String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([jobId, applicantId])
  @@index([jobId, status])
  @@index([applicantId])
}

model StudioReview {
  id              String @id @default(cuid())
  
  // Review content
  rating          Int @db.SmallInt       // 1-5 stars
  comment         String? @db.VarChar(1000)
  
  // Would work again?
  wouldWorkAgain  Boolean @default(true)
  
  // Studio
  studio          Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
  studioId        String
  
  // Reviewer (person who worked for the studio)
  reviewer        User @relation("studioReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewerId      String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([studioId, createdAt])
  @@index([reviewerId])
}

