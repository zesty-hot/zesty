generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  ADMIN
  STAFF
  USER
}

model Images {
  id        String   @id @default(cuid())
  url       String
  width     Int
  height    Int
  altText   String?
  default   Boolean @default(false)
  NSFW      Boolean @default(false)

  user      User?    @relation(fields: [userId], references: [id])
  userId    String?

  createdAt DateTime @default(now())

  @@index([userId], map: "images_userId_idx")
}

enum Race {
  ASIAN
  AFRICAN
  HISPANIC
  WHITE
  DESI
  ARABIC
}

enum BodyType {
  REGULAR
  PLUS
  ATHLETE
}

enum Gender {
  MALE
  FEMALE
  TRANS
}

model User {
  id          String @id @default(cuid())
  accounts     Account[]
  sessions     Session[]

  name        String?
  bio         String? @db.VarChar(1000)
  email       String @unique
  emailVerified DateTime?
  slug        String? @unique
  image       String?
  role        Role    @default(USER)
  dob         DateTime
  stripeId    String?
  verified    Boolean @default(false)
  mobile      String? @db.VarChar(15)
  location    String? @db.VarChar(100) // Latitude, Longitude
  suburb      String? @db.VarChar(100) // Suburb/City name
  bodyType    BodyType?
  race        Race?
  gender      Gender?

  privateAds             PrivateAd[]
  images                 Images[]
  privateOffersSent      PrivateOffer[] @relation("offersSent")
  privateOffersReceived  PrivateOffer[] @relation("offersReceived")

  vipPage             VIPPage?
  vipSubscriptions    VIPSubscription[] @relation("vipSubscriber")
  vipLikes            VIPLike[] @relation("vipLikes")
  vipComments         VIPComment[] @relation("vipComments")

  liveStreamPage      LiveStreamPage?
  liveStreamFollows   LiveStreamFollower[]
  liveStreamDonations LiveStreamDonation[]

  eventsOrganized     Event[] @relation("eventOrganizer")
  eventsAttending     EventAttendee[] @relation("eventAttendee")
  eventPosts          EventPost[] @relation("eventPostAuthor")
  eventComments       EventComment[] @relation("eventCommentAuthor")

  messagesSent ChatMessage[] @relation("sender")
  activeChats  Chat[] @relation("activeChat")
  hiddenChats  Chat[] @relation("hiddenChat")

  reviewsGiven    Review[] @relation("reviewer")
  reviewsReceived Review[] @relation("reviewee")

  lastActive      DateTime? @default(now())
  createdAt       DateTime @default(now())
}

model VIPPage {
  id              String @id @default(cuid())

  title           String @db.VarChar(200)
  description     String @db.VarChar(3000)
  bannerUrl       String? // Banner image for the VIP page
  active          Boolean @default(true)
  
  // Pricing
  subscriptionPrice Int @default(999) // Price in cents (e.g., 999 = $9.99)
  isFree            Boolean @default(false)

  user            User @relation(fields: [userId], references: [id])
  userId          String

  content         VIPContent[]
  subscriptions   VIPSubscription[]
  discountOffers  VIPDiscountOffer[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId])  
}

enum VIPContentType {
  IMAGE
  VIDEO
  STATUS
}

model VIPContent {
  id          String @id @default(cuid())
  
  type        VIPContentType
  caption     String? @db.VarChar(1000)
  
  // For images
  imageUrl    String?
  imageWidth  Int?
  imageHeight Int?
  
  // For videos
  videoUrl    String?
  thumbnailUrl String?
  duration    Int? // Duration in seconds
  
  // For status updates
  statusText  String? @db.VarChar(5000)
  
  NSFW        Boolean @default(false)
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  likes       VIPLike[]
  comments    VIPComment[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([vipPageId, createdAt])
}

model VIPSubscription {
  id          String @id @default(cuid())
  
  subscriber  User @relation("vipSubscriber", fields: [subscriberId], references: [id])
  subscriberId String
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  active      Boolean @default(true)
  expiresAt   DateTime? // Null for lifetime/free subscriptions
  
  // Payment tracking
  amountPaid  Int // Amount in cents
  stripeSubscriptionId String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([subscriberId, vipPageId])
  @@index([subscriberId])
  @@index([vipPageId])
}

model VIPDiscountOffer {
  id          String @id @default(cuid())
  
  vipPage     VIPPage @relation(fields: [vipPageId], references: [id], onDelete: Cascade)
  vipPageId   String
  
  discountPercent Int // 0-100
  discountedPrice Int // Price in cents after discount
  
  active      Boolean @default(true)
  validFrom   DateTime @default(now())
  validUntil  DateTime?
  
  createdAt   DateTime @default(now())

  @@index([vipPageId, active])
}

model VIPLike {
  id          String @id @default(cuid())
  
  user        User @relation("vipLikes", fields: [userId], references: [id])
  userId      String
  
  content     VIPContent @relation(fields: [contentId], references: [id], onDelete: Cascade)
  contentId   String
  
  createdAt   DateTime @default(now())

  @@unique([userId, contentId])
  @@index([contentId])
}

model VIPComment {
  id          String @id @default(cuid())
  
  user        User @relation("vipComments", fields: [userId], references: [id])
  userId      String
  
  content     VIPContent @relation(fields: [contentId], references: [id], onDelete: Cascade)
  contentId   String
  
  text        String @db.VarChar(1000)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([contentId, createdAt])
}

model Review {
  id          String @id @default(cuid())
  comment     String? @db.VarChar(1000)
  rating      Int @db.SmallInt

  reviewer    User @relation("reviewer", fields: [reviewerId], references: [id])
  reviewerId  String

  reviewee    User @relation("reviewee", fields: [revieweeId], references: [id])
  revieweeId  String
 
  offer       PrivateOffer? @relation(fields: [offerId], references: [id])
  offerId     String?

  createdAt   DateTime @default(now())  
}

model Account {
  id                String  @id @default(cuid())
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum PrivateAdExtraType {
  FILMING
  BJ
  ANAL
  BDSM
  NATURAL
  EXTRA_PERSON
  OUTSIDE_LOCATION
  COSTUME
  ROLEPLAY
  TOY_USE
  CREAMPIE
  GOLDEN_SHOWER
}

enum PrivateAdCustomerCategory {
  MEN
  WOMEN
  GROUPS
  TRANSGENDER
  DISABLED
}

enum PrivateAdServiceCategory {
  MASSAGE
  IN_CALL
  OUT_CALL
  MEET_AND_GREET
}

enum DaysAvailable {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

model PrivateAdService {
  id            String @id @default(cuid())

  privateAd     PrivateAd @relation(fields: [privateAdId], references: [id])
  privateAdId   String

  category      PrivateAdServiceCategory // IN_CALL, OUT_CALL, NON_SEXUAL, OVERNIGHT
  label         String? // optional display name, e.g. “Public meet-up”

  options       ServiceOption[] // durations and prices

  createdAt     DateTime @default(now())
}

model ServiceOption {
  id            String @id @default(cuid())
  service       PrivateAdService @relation(fields: [serviceId], references: [id])
  serviceId     String

  durationMin   Int      // 15, 30, 60
  price         Int      // price in dollars
}

model PrivateAdExtra {
  id            String @id @default(cuid())
  privateAd     PrivateAd @relation(fields: [privateAdId], references: [id])
  privateAdId   String

  name          PrivateAdExtraType // BJ, ANAL, BDSM, FILMING
  price         Int
  active        Boolean @default(true)
}

model PrivateAd {
  id              String @id @default(cuid())

  title           String @db.VarChar(200)
  description     String @db.VarChar(3000)
  active          Boolean @default(true)

  services        PrivateAdService[]
  acceptsGender   PrivateAdCustomerCategory[]
  acceptsRace     Race[]
  acceptsBodyType BodyType[]
  acceptsAgeRange Int[]  // [minAge, maxAge]
  extras          PrivateAdExtra[]
  daysAvailable   DaysAvailable[]

  worker          User @relation(fields: [workerId], references: [id])
  workerId        String

  createdAt       DateTime @default(now())

  @@unique([workerId])
}

enum PrivateOfferStatus {
  PENDING
  CONFIRMED
  DISPUTED
  RELEASED
}

model PrivateOffer {
  id            String @id @default(cuid())
  amount        Int
  adId          String

  status        PrivateOfferStatus @default(PENDING)
  expiresAt     DateTime?

  client        User @relation("offersSent", fields: [clientId], references: [id])
  clientId      String
  worker        User @relation("offersReceived", fields: [workerId], references: [id])
  workerId      String

  chat          Chat? @relation(fields: [chatId], references: [id])
  chatId        String?

  createdAt     DateTime @default(now())

  Review Review[]
}

model Chat {
  id        String @id @default(cuid())
  messages  ChatMessage[]

  createdAt DateTime @default(now())

  activeUsers User[] @relation("activeChat")
  hiddenUsers User[] @relation("hiddenChat")

  PrivateOffer PrivateOffer[]
}

model ChatMessage {
  id        String @id @default(cuid())

  sender    User    @relation("sender", fields: [senderId], references: [id])
  senderId  String

  content   String @db.VarChar(1000)

  createdAt DateTime @default(now())

  chat Chat @relation(fields: [chatId], references: [id])
  chatId String
}

// LiveStreamPage is a channel/profile for livestreaming (like a sub-account)
// It can be enabled/disabled and has its own followers
model LiveStreamPage {
  id              String @id @default(cuid())
  slug            String @unique
  
  title           String @db.VarChar(200)
  description     String? @db.VarChar(3000)
  bannerUrl       String?          // Banner image for the channel
  
  active          Boolean @default(false)  // Channel enabled/disabled
  
  // RTMP/Stream key for broadcasting (persistent per channel)
  ingressId       String?          // LiveKit ingress ID for RTMP/WHIP
  streamKey       String?          // Stream key for broadcasting
  
  // Relations
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  followers       LiveStreamFollower[]
  streams         LiveStream[]     // Individual streaming sessions
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId])
  @@index([active, createdAt])
  @@index([slug])
}

// Individual live stream sessions within a channel
model LiveStream {
  id              String @id @default(cuid())
  
  title           String? @db.VarChar(200)  // Optional custom title for this session
  
  isLive          Boolean @default(true)    // Currently streaming
  roomName        String @unique            // LiveKit room for this session
  
  viewerCount     Int @default(0)           // Current/peak viewers
  
  startedAt       DateTime @default(now())
  endedAt         DateTime?
  
  // Relations
  channel         LiveStreamPage @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelId       String
  
  donations       LiveStreamDonation[]
  
  @@index([channelId, isLive])
  @@index([isLive, startedAt])
}

// Followers for livestream channels
model LiveStreamFollower {
  id              String @id @default(cuid())
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  channel         LiveStreamPage @relation(fields: [channelId], references: [id], onDelete: Cascade)
  channelId       String
  
  createdAt       DateTime @default(now())

  @@unique([userId, channelId])
  @@index([channelId])
  @@index([userId])
}

// Donations/tips to live streams
model LiveStreamDonation {
  id              String @id @default(cuid())
  
  amount          Int              // Amount in cents
  message         String? @db.VarChar(500)
  
  donor           User? @relation(fields: [donorId], references: [id])
  donorId         String?
  
  stream          LiveStream @relation(fields: [streamId], references: [id], onDelete: Cascade)
  streamId        String
  
  createdAt       DateTime @default(now())

  @@index([streamId, createdAt])
}

// ==================== EVENTS ====================

enum EventStatus {
  OPEN                // Anyone can join
  INVITE_ONLY        // Only invited users can join
  PAY_TO_JOIN        // Payment required to join
  REQUEST_TO_JOIN    // Users request, host approves
}

model Event {
  id              String @id @default(cuid())
  
  title           String @db.VarChar(200)
  description     String? @db.Text
  slug            String @unique
  
  // Location
  location        String? @db.VarChar(100)  // Latitude, Longitude
  suburb          String? @db.VarChar(100)  // Suburb/City name
  venue           String? @db.VarChar(200)  // Venue name/address
  
  // Images
  coverImage      String?
  
  // Event details
  startTime       DateTime
  endTime         DateTime?
  status          EventStatus @default(OPEN)
  price           Int? // Price in cents (if PAY_TO_JOIN)
  maxAttendees    Int? // Maximum number of attendees
  
  // Organizer
  organizer       User @relation("eventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  organizerId     String
  
  // Relations
  attendees       EventAttendee[]
  posts           EventPost[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([organizerId])
  @@index([startTime])
  @@index([suburb, startTime])
  @@index([status, startTime])
}

model EventAttendee {
  id              String @id @default(cuid())
  
  // Attendee status
  status          EventAttendeeStatus @default(PENDING)
  
  event           Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId         String
  
  user            User @relation("eventAttendee", fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([eventId, status])
  @@index([userId])
}

enum EventAttendeeStatus {
  PENDING         // Requested to join (for REQUEST_TO_JOIN events)
  GOING           // Confirmed attendance
  MAYBE           // Interested/maybe going
  DECLINED        // Declined invitation
  INVITED         // Invited but not responded (for INVITE_ONLY)
}

model EventPost {
  id              String @id @default(cuid())
  
  content         String @db.Text
  
  event           Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId         String
  
  author          User @relation("eventPostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  authorId        String
  
  comments        EventComment[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([eventId, createdAt])
  @@index([authorId])
}

model EventComment {
  id              String @id @default(cuid())
  
  content         String @db.Text
  
  post            EventPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId          String
  
  author          User @relation("eventCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  authorId        String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([authorId])
}
